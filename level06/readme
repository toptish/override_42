Программа вызывает функцию `auth`, которая принимает строку и целое число в качестве аргументов, 
если эта функция возвращает 1, она вызывает sh через `system`.
Эти строка и целое число взяты из пользовательского ввода.
Мы можем легко заметить, что неизменное целое число сравнивается с каким-то ключом, 
заданным с помощью некоторого шифрования на основе строки.
Эта строка должна быть длиннее 5 символов, чтобы быть действительной.
Присутствует также вызов ptrace, для предотвращения использования программы отладчика,
это потребует от нас обойти его в GDB.
Поскольку целочисленный ключ никогда не изменяется в алгоритме, он зависит только от строки.
Мы можем просто использовать gdb для проверки переменных во время выполнения и посмотреть,
какое у ключа значение, учитывая некоторую произвольную строку.
Мы также не должны забывать отключить проверку ptrace, 
установив регистру `eax` значение 0 после вызова ptrace.
Учитывая произвольно выбранный логин “ophuong”, мы видим, что связанный ключ - 6233802.
Теперь мы можем запустить программу без GDB, чтобы получить доступ к следующему уровню.

login  : ophuong
serial : 6233802

Запускаем GDB для level06:
	gdb level06

Для получения ключа совершаем следующие манипуляции в среде GDB:

1. Находим при помощи команды (gdb) disass auth
	важные нам инструкции в функции аутентификации:
		0x080487ba <+114>:		cmp    $0xffffffff,%eax
		0x08048866 <+286>:		cmp    -0x10(%ebp),%eax

2. Устанавливаем beakepoints:
		(gdb) b*main
		Breakpoint 1 at 0x8048879
		(gdb) b*auth
		Breakpoint 2 at 0x8048748
		(gdb) b *0x080487ba
		Breakpoint 3 at 0x80487ba
		(gdb) b *0x08048866
		Breakpoint 4 at 0x8048866

3. Запускаем программу в среде GDB:
		(gdb) r
		Starting program: /home/users/level06/level06 

		Breakpoint 1, 0x08048879 in main ()
		(gdb) c
		Continuing.
4. Вводим логин длиннее 5 символов:
		***********************************
		*		level06		  *
		***********************************
		-> Enter Login: ophuong
5. Вводим число:
		***********************************
		***** NEW ACCOUNT DETECTED ********
		***********************************
		-> Enter Serial: 42	

		Breakpoint 2, 0x08048748 in auth ()
		(gdb) c
		Continuing.
6. Устанавливаем в регистр eax значение 0 для обхода ptrace:
		Breakpoint 3, 0x080487ba in auth ()
		(gdb) set $eax=0
		(gdb) c
		Continuing.
7. Смотрим с каким числом сравнивают введенный ключ:
		Breakpoint 4, 0x08048866 in auth ()
		(gdb) x/wx $ebp-0x10
		0xffffd688:	0x005f1eca												#Hex -> Dec: 6233802
		(gdb) q
		A debugging session is active.

		Inferior 1 [process 2044] will be killed.

		Quit anyway? (y or n) y
8. Проходим успешную аутентификацию с использованием полученного ключа:
		level06@OverRide:~$ ./level06 
		***********************************
		*		level06		  *
		***********************************
		-> Enter Login: ophuong
		***********************************
		***** NEW ACCOUNT DETECTED ********
		***********************************
		-> Enter Serial: 6233802
		Authenticated!
		$ 
9. Получаем пароль от следующего уровня:
		$ whoami  
		level07
		$ cat /home/users/level07/.pass
		GbcPDRgsFK77LNnnuh7QyFYA2942Gp8yKj9KrWD8							#flag 